{
  "name": "async-next",
  "version": "0.1.13",
  "description": "Async callback manager.  Use async.now to run a set of functions in parallel or async.next to run in series.",
  "main": "lib/async.js",
  "scripts": {
    "test": "mocha test/index.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/kbscript/async-next/"
  },
  "keywords": [
    "async",
    "callback",
    "next"
  ],
  "author": {
    "name": "Kevin Barnett",
    "email": "kevinbarnett5506@gmail.com"
  },
  "license": "BSD-2-Clause",
  "bugs": {
    "url": "https://github.com/kbscript/async-next/issues"
  },
  "homepage": "https://github.com/kbscript/async-next",
  "readme": "async-next\r\n=============\r\n\r\nAsync callback manager. Use async.now to run a set of functions in parallel or async.next to run in series.\r\n\r\n## Install\r\n\r\n````\r\nnpm install async-next\r\n````\r\n\r\n## Series Example\r\n\r\n````js\r\nvar Async = require('async-next');\r\nvar async = new Async();\r\n\r\nasync.next(function (next) {\r\n    var count = 0;\r\n    console.log('doing step 1');\r\n    count++;\r\n    next({value: \"new value\"}, count);\r\n});\r\n\r\nasync.next(function (next, paramsFromFirstAsyncNext, count) {\r\n    console.log('doing step 2');\r\n    console.log('using passed params: ' + paramsFromFirstAsyncNext.value + \" count: \" + count);\r\n    next();\r\n});\r\n\r\nasync.next.start(function () {\r\n  console.log('All done.');\r\n});\r\n\r\n````\r\n\r\n## Async Example\r\n\r\n````js\r\nvar async = new Async();\r\nvar path = require('path'), fs = require('fs');\r\nvar filesToUpdate = [], i;\r\n\r\n//build file array to use as test update\r\nfor (i=0; i < 3; i++) {\r\n    filesToUpdate.push({path: path.join(__dirname,'./files/file' + i + 'txt'), text: 'New Test Data for file: ' + i})\r\n}\r\n\r\n//now run async update\r\nfor (i=0; i < filesToUpdate.length; i++){\r\n    async.now(function (next, file) {\r\n        fs.writeFile(file.path,file.text, function(){\r\n            console.log('done updating file: ' + file.path);\r\n            next();\r\n        });\r\n    }, filesToUpdate[i]);\r\n}\r\n\r\nasync.now.start(function(){\r\n    console.log('Done with Async');\r\n});\r\n````\r\n\r\n## Combined async.next and async.now with nesting\r\n\r\n````js\r\nvar async = new Async();\r\n\r\nasync.next(function series1 (next){\r\n\r\n    //starting a nested async.next will require all nested async calls to complete before the outer async.next will continue;\r\n    async.next(function series1Nested1(next){\r\n        console.log('done with series1Nested1');\r\n        next();\r\n    });\r\n\r\n    async.next(function series1Nested2(next){\r\n        console.log('done with series1Nested2');\r\n        next();\r\n    });\r\n      async.next(function series1Nested3(next){\r\n        console.log('done with series1Nested3');\r\n\r\n        //calling next() on the last nested async.next will resume the outer async.next\r\n        next();\r\n    });\r\n\r\n    //all nested async.next or async.now calls are started on nextTick.  That means their parent function will complete before they start.\r\n    console.log('done with series1');\r\n    //calling the outer async.next after adding nested async.next calls will start them - the outer async.next will continue after the last nested async.next has been called.\r\n    next();\r\n});//end async.next series1\r\n\r\nasync.next(function series2 (next){\r\n    var path = require('path'), fs = require('fs');\r\n    var filesToUpdate = [], i;\r\n\r\n    //build file array to use as test update\r\n    for (i=0; i < 3; i++) {\r\n        filesToUpdate.push({path: path.join(__dirname,'./files/file' + i + 'txt'), text: 'New Test Data for file: ' + i})\r\n    }\r\n\r\n    //now run async update\r\n    for (i=0; i < filesToUpdate.length; i++){\r\n        async.now(function (next, file) {\r\n            fs.writeFile(file.path,file.text, function(){\r\n                console.log('done updating file: ' + file.path);\r\n                next();\r\n            });\r\n        }, filesToUpdate[i]);\r\n    }\r\n\r\n    async.now.start(function(){\r\n        console.log('done with nested async.now');\r\n\r\n        //we need to call the outer next callback for the series2 function to continue our outer async.next series.\r\n        next();\r\n    });\r\n\r\n    //all nested async.next or async.now calls are started on nextTick.  That means their parent function will complete before they start.\r\n    console.log('done with series2');\r\n});//end async.next series2\r\n\r\nasync.next(function series3 (next){\r\n    console.log('done with series3');\r\n    next();\r\n});//end async.next series3\r\n\r\nasync.next.start(function(){\r\n    console.log('all done with combined example.\\n\\n');\r\n});\r\n````\r\n\r\n## License\r\n\r\n[MIT](LICENSE)\r\n",
  "readmeFilename": "README.md",
  "gitHead": "94499bdce83a7ef3a9820c9e0d7f00e8baf45ae5",
  "_id": "async-next@0.1.13",
  "_shasum": "c55f93c00c2ff8be1e52d6fa293e24f81284f3de",
  "_from": "async-next@>=0.1.11 <0.2.0"
}
